import { exec } from 'child_process';
import { promisify } from 'util';
import { randomBytes } from 'crypto';
import * as path from 'path';
import * as os from 'os';
import * as fs from 'fs/promises';
import { SayFn } from '@slack/bolt';

// We only need the simple execPromise-based command runner
const execPromise = promisify(exec);

async function runCommand(
  command: string,
  options?: { cwd: string },
): Promise<{ stdout: string; stderr: string }> {
  const cwd = options?.cwd || process.cwd();
  console.log(`[${cwd}]> ${command}`);
  try {
    // Increase the maxBuffer size for potentially large AI outputs
    const { stdout, stderr } = await execPromise(command, { ...options, maxBuffer: 1024 * 1024 * 10 }); // 10 MB
    if (stdout) console.log(stdout);
    if (stderr) console.error('STDERR:', stderr);
    return { stdout, stderr };
  } catch (error: any) {
    const detailedErrorMessage = `Command failed: ${command}\nSTDOUT: ${error.stdout}\nSTDERR: ${error.stderr}`;
    throw new Error(detailedErrorMessage);
  }
}

export async function runAgentTask(
  prompt: string,
  say: SayFn, // The function to send messages
  threadTs: string, // The ID of the message to reply to
): Promise<string> {
  const repoUrl = process.env.TARGET_REPO_URL;
  if (!repoUrl) {
    throw new Error('TARGET_REPO_URL environment variable is not set.');
  }

  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ai-agent-'));

  try {
    await runCommand(`git clone ${repoUrl} .`, { cwd: tempDir });
    await say({ text: '✅ Cloned repository successfully.', thread_ts: threadTs });

    const uniqueId = randomBytes(4).toString('hex');
    const branchName = `ai-agent/${prompt.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '').slice(0, 20)}-${uniqueId}`;
    
    await runCommand(`git checkout -b ${branchName}`, { cwd: tempDir });

    // --- NEW TWO-STEP PROCESS ---

    // 1. Generate the plan
    await say({ text: '🤔 Generating an implementation plan...', thread_ts: threadTs });
    const planningPrompt = `Based on the user request, create a detailed implementation plan. Do not execute any commands or modify any files; only output the plan. The user\'s request is: "${prompt}"`;
    const { stdout: plan } = await runCommand(`qwen -p "${planningPrompt}"`, { cwd: tempDir });
    
    await say({
      text: `Here\'s the plan:\n\`\`\`\n${plan}\n\`\`\`\nI will now proceed with the implementation.`,
      thread_ts: threadTs,
    });

    // 2. Execute the plan
    await say({ text: '⏳ Implementing the plan... this is the longest step and may take a few minutes.', thread_ts: threadTs });
    const executionPrompt = `Please execute the following plan:\n\n${plan}`;
    await runCommand(`qwen -p "${executionPrompt}" -y`, { cwd: tempDir });
    await say({ text: '📝 AI has finished. Committing changes and pushing to a new branch...', thread_ts: threadTs });
    // -----------------------------

    const commitMessage = `feat: AI-driven changes for ${prompt.slice(0, 50)}...`;
    await runCommand('git add .', { cwd: tempDir });

    const statusResult = await runCommand('git status --porcelain', { cwd: tempDir });
    if (!statusResult.stdout.trim()) {
      return `Task complete for prompt: "*${prompt}*". The AI found no changes to make.`;
    }

    await runCommand(`git commit -m "${commitMessage}"`, { cwd: tempDir });
    await runCommand(`git push origin ${branchName}`, { cwd: tempDir });

    await say({ text: '🔗 Creating Pull Request on GitHub...', thread_ts: threadTs });
    const prTitle = `AI Agent: ${prompt}`;
    const prBody = `This PR was automatically generated by the AI agent based on the prompt:\n\n> ${prompt}`;
    const { stdout: prOutput } = await runCommand(
      `gh pr create --title "${prTitle}" --body "${prBody}" --base "main"`,
      { cwd: tempDir },
    );

    const prUrl = prOutput.trim();
    return `✅ Task complete! A pull request has been created: ${prUrl}`;
  } catch (error: any) {
    throw new Error(`Agent task failed: ${error.message || 'Unknown error occurred'}.`);
  } finally {
    await fs.rm(tempDir, { recursive: true, force: true });
  }
}