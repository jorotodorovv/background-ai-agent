import { exec } from 'child_process';
import { promisify } from 'util';
import { randomBytes } from 'crypto';
import * as path from 'path';
import * as os from 'os';
import * as fs from 'fs/promises';

// Promisify exec for async/await usage
const execPromise = promisify(exec);

/**
 * A utility to run shell commands and log their output.
 * @param command The command to execute.
 * @param options The options for the child process, including the working directory.
 */
async function runCommand(
  command: string,
  options?: { cwd: string },
): Promise<{ stdout: string; stderr: string }> {
  const cwd = options?.cwd || process.cwd();
  console.log(`[${cwd}]> ${command}`);
  try {
    const { stdout, stderr } = await execPromise(command, { ...options });
    if (stdout) console.log(stdout);
    if (stderr) console.error('STDERR:', stderr);
    return { stdout, stderr };
  } catch (error) {
    console.error(`Error executing command: "${command}"`, error);
    throw error;
  }
}

/**
 * The main function for the AI agent's task.
 * @param prompt The user's instruction for the AI.
 */
export async function runAgentTask(prompt: string): Promise<string> {
  const repoUrl = process.env.TARGET_REPO_URL;
  if (!repoUrl) {
    throw new Error('TARGET_REPO_URL environment variable is not set.');
  }

  // 1. Create a unique temporary directory for this specific task
  // Using os.tmpdir() ensures it's in the system's designated temp location
  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ai-agent-'));
  console.log(`Created temporary directory: ${tempDir}`);

  try {
    // 2. Clone the repository into the temporary directory
    // This makes the operation isolated and prevents conflicts
    console.log(`Cloning ${repoUrl} into ${tempDir}`);
    await runCommand(`git clone ${repoUrl} .`, { cwd: tempDir });

    // 3. Create a new git branch for the changes
    const uniqueId = randomBytes(4).toString('hex');
    const branchName = `ai-agent/${prompt
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '')
      .slice(0, 20)}-${uniqueId}`; // Sanitize prompt for branch name

    console.log(`Creating and checking out new branch: ${branchName}`);
    await runCommand('git checkout main', { cwd: tempDir }); // Ensure we're on main before branching
    await runCommand('git pull origin main', { cwd: tempDir }); // Sync main branch
    await runCommand(`git checkout -b ${branchName}`, { cwd: tempDir });

    // 4. Run the AI code generation tool (Qwen CLI)
    console.log('\n--- Running Qwen AI Agent ---');
    // IMPORTANT: Ensure 'qwen-code-cli' is installed and executable on your VPS.
    // The '--apply' flag is an assumption that it modifies files directly.
    await runCommand(`qwen-code-cli --prompt "${prompt}" --apply`, {
      cwd: tempDir,
    });
    console.log('--- Qwen AI Agent Finished ---\n');

    // 5. Commit, Push, and Create a Pull Request
    const commitMessage = `feat: AI-driven changes for "${prompt.slice(
      0,
      50,
    )}..."`; // Truncate for commit message
    await runCommand('git add .', { cwd: tempDir });

    // Check if the AI actually made any changes
    const statusResult = await runCommand('git status --porcelain', {
      cwd: tempDir,
    });
    if (!statusResult.stdout.trim()) {
      console.log('The AI made no changes to the code. No commit or PR needed.');
      return `Task complete for prompt: "*${prompt}*". The AI found no changes to make.`;
    }

    // Commit changes
    await runCommand(`git commit -m "${commitMessage}"`, { cwd: tempDir });
    // Push the new branch to the remote
    await runCommand(`git push origin ${branchName}`, { cwd: tempDir });

    // Create the Pull Request using GitHub CLI
    const prTitle = `AI Agent: ${prompt}`;
    const prBody = `This PR was automatically generated by the AI agent based on the prompt:\n\n> ${prompt}`;
    const { stdout: prOutput } = await runCommand(
      `gh pr create --title "${prTitle}" --body "${prBody}" --base "main"`,
      { cwd: tempDir },
    );

    const prUrl = prOutput.trim(); // The gh CLI outputs the PR URL on success
    console.log(`âœ… Successfully created Pull Request: ${prUrl}`);
    return `Task complete! A pull request has been created: ${prUrl}`;
  } catch (error: any) {
    // Log and re-throw errors to be handled by the Slack controller
    console.error('An error occurred during agent task:', error.message || error);
    // Even if an error occurs, the finally block will ensure cleanup
    throw new Error(
      `Agent task failed: ${error.message || 'Unknown error occurred'}.`,
    );
  } finally {
    // 6. GUARANTEED CLEANUP: Always remove the temporary directory
    console.log(`Cleaning up temporary directory: ${tempDir}`);
    // force: true ensures it deletes even if there are permission issues,
    // recursive: true for non-empty directories
    await fs.rm(tempDir, { recursive: true, force: true });
  }
}